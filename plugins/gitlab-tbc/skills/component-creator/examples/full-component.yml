# =========================================================================================
# Full-Featured to-be-continuous Component Example
# Based on REAL patterns from docker, semantic-release, kubernetes components
#
# This example shows ALL required elements for a production-ready TBC component
# Source: https://gitlab.com/to-be-continuous/docker/-/raw/master/templates/gitlab-ci-docker.yml
# =========================================================================================

# ==============================================================================
# COMPONENT SPEC (CI/CD Component Inputs)
# ==============================================================================
spec:
  inputs:
    # Required inputs (no default = required)
    app-name:
      description: "Application name for deployment"
      type: string

    # Optional inputs with defaults
    image:
      description: "Container image to use for jobs"
      type: string
      default: "alpine:3.19"

    build-args:
      description: "Additional build arguments"
      type: string
      default: ""

    build-disabled:
      description: "Disable build job"
      type: boolean
      default: false

    test-disabled:
      description: "Disable test job"
      type: boolean
      default: false

    lint-disabled:
      description: "Disable lint job"
      type: boolean
      default: false

    publish-disabled:
      description: "Disable publish job"
      type: boolean
      default: false

    # Enumerated options
    build-tool:
      description: "Tool to use for building"
      type: string
      options:
        - maven
        - gradle
        - npm
        - default
      default: "default"

---
# ==============================================================================
# GLOBAL VARIABLES (TBC standard patterns)
# ==============================================================================
variables:
  # Component defaults (mapped from inputs)
  EXAMPLE_IMAGE: $[[ inputs.image ]]
  EXAMPLE_APP_NAME: $[[ inputs.app-name ]]
  EXAMPLE_BUILD_TOOL: $[[ inputs.build-tool ]]
  EXAMPLE_BUILD_ARGS: $[[ inputs.build-args ]]

  # Disabled flags (mapped from inputs)
  EXAMPLE_BUILD_DISABLED: $[[ inputs.build-disabled ]]
  EXAMPLE_TEST_DISABLED: $[[ inputs.test-disabled ]]
  EXAMPLE_LINT_DISABLED: $[[ inputs.lint-disabled ]]
  EXAMPLE_PUBLISH_DISABLED: $[[ inputs.publish-disabled ]]

  # TBC standard ref patterns (can be overridden by users)
  PROD_REF: '/^(master|main)$/'
  INTEG_REF: '/^develop$/'
  RELEASE_REF: '/^v?[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9\-\.]+)?(\+[a-zA-Z0-9\-\.]+)?$/'

  # TBC tracking service
  TBC_TRACKING_IMAGE: "registry.gitlab.com/to-be-continuous/tools/tracking:master"

# ==============================================================================
# TBC WORKFLOW RULES (standard patterns from to-be-continuous ecosystem)
# These are the REAL rules used by all TBC components
# ==============================================================================
.tbc-workflow-rules:
  # Prevent MR pipeline originating from production or integration branch(es)
  skip-back-merge:
    - if: '$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ $PROD_REF || $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ $INTEG_REF'
      when: never

  # On non-prod, non-integration branches: prefer MR pipeline over branch pipeline
  # ⚠️ can't be used with prefer-branch-pipeline rule
  prefer-mr-pipeline:
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS && $CI_COMMIT_REF_NAME !~ $PROD_REF && $CI_COMMIT_REF_NAME !~ $INTEG_REF'
      when: never

  # Prefer branch pipeline over MR pipeline
  # ⚠️ can't be used with prefer-mr-pipeline rule
  prefer-branch-pipeline:
    - if: $CI_MERGE_REQUEST_ID
      when: never

  # Extended "[skip ci]" behavior with scope annotations
  extended-skip-ci:
    - if: '$CI_COMMIT_MESSAGE =~ "/\[(ci skip|skip ci) on ([^],]*,)*tag(,[^],]*)*\]/" && $CI_COMMIT_TAG'
      when: never
    - if: '$CI_COMMIT_MESSAGE =~ "/\[(ci skip|skip ci) on ([^],]*,)*branch(,[^],]*)*\]/" && $CI_COMMIT_BRANCH'
      when: never
    - if: '$CI_COMMIT_MESSAGE =~ "/\[(ci skip|skip ci) on ([^],]*,)*mr(,[^],]*)*\]/" && $CI_MERGE_REQUEST_ID'
      when: never
    - if: '$CI_COMMIT_MESSAGE =~ "/\[(ci skip|skip ci) on ([^],]*,)*default(,[^],]*)*\]/" && $CI_COMMIT_REF_NAME =~ $CI_DEFAULT_BRANCH'
      when: never
    - if: '$CI_COMMIT_MESSAGE =~ "/\[(ci skip|skip ci) on ([^],]*,)*prod(,[^],]*)*\]/" && $CI_COMMIT_REF_NAME =~ $PROD_REF'
      when: never
    - if: '$CI_COMMIT_MESSAGE =~ "/\[(ci skip|skip ci) on ([^],]*,)*integ(,[^],]*)*\]/" && $CI_COMMIT_REF_NAME =~ $INTEG_REF'
      when: never
    - if: '$CI_COMMIT_MESSAGE =~ "/\[(ci skip|skip ci) on ([^],]*,)*dev(,[^],]*)*\]/" && $CI_COMMIT_REF_NAME !~ $PROD_REF && $CI_COMMIT_REF_NAME !~ $INTEG_REF'
      when: never

  # TBC default rules (MR workflow policy)
  default:
    - !reference [.tbc-workflow-rules, skip-back-merge]
    - !reference [.tbc-workflow-rules, prefer-mr-pipeline]
    - !reference [.tbc-workflow-rules, extended-skip-ci]

# ==============================================================================
# WORKFLOW (uses TBC standard rules)
# ==============================================================================
workflow:
  rules:
    - !reference [.tbc-workflow-rules, default]
    - when: always

# ==============================================================================
# TEST POLICY: Adaptive pipeline rules for quality/test jobs
# ==============================================================================
.test-policy:
  rules:
    # On tag: auto & failing
    - if: $CI_COMMIT_TAG
    # On ADAPTIVE_PIPELINE_DISABLED: auto & failing
    - if: '$ADAPTIVE_PIPELINE_DISABLED == "true"'
    # On production or integration branch(es): auto & failing
    - if: '$CI_COMMIT_REF_NAME =~ $PROD_REF || $CI_COMMIT_REF_NAME =~ $INTEG_REF'
    # Early stage (dev branch, no MR): manual & non-failing
    - if: '$CI_MERGE_REQUEST_ID == null && $CI_OPEN_MERGE_REQUESTS == null'
      when: manual
      allow_failure: true
    # Draft MR: auto & non-failing
    - if: '$CI_MERGE_REQUEST_TITLE =~ /^Draft:.*/'
      allow_failure: true
    # Else (Ready MR): auto & failing
    - when: on_success

# ==============================================================================
# DELIVERY POLICY: Rules for publish/release jobs
# ==============================================================================
.delivery-policy:
  rules:
    # On tag with release pattern
    - if: '$CI_COMMIT_TAG =~ $RELEASE_REF'
    # On production or integration branch(es)
    - if: '$CI_COMMIT_REF_NAME =~ $PROD_REF || $CI_COMMIT_REF_NAME =~ $INTEG_REF'

# ==============================================================================
# STAGES DEFINITION (TBC standard 11-stage sequence)
# ==============================================================================
stages:
  - build
  - test
  - package-build
  - package-test
  - infra
  - deploy
  - acceptance
  - publish
  - infra-prod
  - production

# ==============================================================================
# REUSABLE SCRIPTS (YAML anchor - TBC standard patterns)
# ==============================================================================
.example-scripts: &example-scripts |
  # BEGSCRIPT
  set -e

  function log_info() { echo -e "[\e[1;94mINFO\e[0m] $*"; }
  function log_warn() { echo -e "[\e[1;93mWARN\e[0m] $*"; }
  function log_error() { echo -e "[\e[1;91mERROR\e[0m] $*"; }
  function fail() { log_error "$*"; exit 1; }

  # ==== Custom CA Certificates (TBC pattern) ====
  function install_custom_ca_certs() {
    certs="${CUSTOM_CA_CERTS:-$DEFAULT_CA_CERTS}"
    if [[ -z "$certs" ]]; then return; fi

    if [[ -w /etc/ssl/certs/ca-certificates.crt ]]; then
      echo "$certs" | tr -d '\r' >> /etc/ssl/certs/ca-certificates.crt
      log_info "Custom CA certificates imported in \e[33;1m/etc/ssl/certs/ca-certificates.crt\e[0m"
    elif [[ -f /etc/ssl/certs/ca-bundle.crt ]]; then
      echo "$certs" | tr -d '\r' >> /etc/ssl/certs/ca-bundle.crt
      log_info "Custom CA certificates imported in \e[33;1m/etc/ssl/certs/ca-bundle.crt\e[0m"
    fi
  }

  # ==== Package Manager Detection (multi-distro) ====
  function maybe_install_awk() {
    if ! command -v awk > /dev/null; then
      if command -v apt-get > /dev/null; then
        apt-get update && apt-get install --no-install-recommends --yes --quiet awk
      elif command -v apk > /dev/null; then
        apk add --no-cache gawk
      elif command -v dnf > /dev/null; then
        dnf install -y -q awk
      else
        log_error "... didn't find any supported package manager to install awk"
        exit 1
      fi
    fi
  }

  function maybe_install_python3() {
    if ! command -v python3 > /dev/null; then
      if command -v apt-get > /dev/null; then
        apt-get update && apt-get install --no-install-recommends --yes --quiet python3
      elif command -v apk > /dev/null; then
        apk add --no-cache python3
      elif command -v dnf > /dev/null; then
        dnf install -y -q python3
      else
        log_error "... didn't find any supported package manager to install python3"
        exit 1
      fi
    fi
  }

  # ==== Scoped Variables Processing (TBC pattern) ====
  function unscope_variables() {
    _scoped_vars=$(env | awk -F '=' "/^scoped__[a-zA-Z0-9_]+=/ {print \$1}" | sort)
    if [[ -z "$_scoped_vars" ]]; then return; fi
    log_info "Processing scoped variables..."
    for _scoped_var in $_scoped_vars; do
      _fields=${_scoped_var//__/:}
      _target_var=$(echo "$_fields" | cut -d: -f2)
      _condition=$(echo "$_fields" | cut -d: -f3)
      _cond_var=$(echo "$_fields" | cut -d: -f4)
      _cond_val=$(eval echo "\$${_cond_var}")
      _test_op=$(echo "$_fields" | cut -d: -f5)

      case "$_condition" in
        if) _not="";;
        ifnot) _not=1;;
        *) log_warn "... unrecognized condition \e[1;91m$_condition\e[0m in \e[33;1m${_scoped_var}\e[0m"; continue;;
      esac

      case "$_test_op" in
        defined)
          if [[ -z "$_not" ]] && [[ -z "$_cond_val" ]]; then continue; fi
          if [[ "$_not" ]] && [[ "$_cond_val" ]]; then continue; fi
          ;;
        equals|startswith|endswith|contains|in|equals_ic|startswith_ic|endswith_ic|contains_ic|in_ic)
          _cmp_val_prefix="scoped__${_target_var}__${_condition}__${_cond_var}__${_test_op}__"
          _cmp_val=${_scoped_var#"$_cmp_val_prefix"}
          case "$_test_op" in
            equals*) if [[ -z "$_not" ]] && [[ "$_cond_val" != "$_cmp_val" ]]; then continue; fi;;
            startswith*) if [[ -z "$_not" ]] && [[ ! "$_cond_val" =~ ^"$_cmp_val" ]]; then continue; fi;;
            endswith*) if [[ -z "$_not" ]] && [[ ! "$_cond_val" =~ "$_cmp_val"$ ]]; then continue; fi;;
            contains*) if [[ -z "$_not" ]] && [[ ! "$_cond_val" =~ "$_cmp_val" ]]; then continue; fi;;
          esac
          ;;
        *) log_warn "... unrecognized test operator \e[1;91m${_test_op}\e[0m"; continue;;
      esac

      _val=$(eval echo "\$${_scoped_var}")
      export "${_target_var}"="${_val}"
      log_info "... apply \e[32m${_target_var}\e[0m from \e[32m\$${_scoped_var}\e[0m"
    done
    log_info "... done"
  }

  # ==== Secret Evaluation (TBC pattern: @b64@, @hex@, @url@) ====
  function eval_secret() {
    name=$1
    value=$(eval echo "\$${name}")
    mkdir -p /tmp

    case "$value" in
      @b64@*)
        decoded=$(mktemp)
        if echo "$value" | cut -c6- | base64 -d > "${decoded}" 2>/dev/null; then
          export ${name}="$(cat ${decoded})"
          log_info "Successfully decoded base64 secret \e[33;1m${name}\e[0m"
        else
          fail "Failed decoding base64 secret \e[33;1m${name}\e[0m"
        fi
        ;;
      @hex@*)
        decoded=$(mktemp)
        if echo "$value" | cut -c6- | sed 's/\([0-9A-F]\{2\}\)/\\x\1/gI' | xargs printf > "${decoded}" 2>/dev/null; then
          export ${name}="$(cat ${decoded})"
          log_info "Successfully decoded hexadecimal secret \e[33;1m${name}\e[0m"
        else
          fail "Failed decoding hexadecimal secret \e[33;1m${name}\e[0m"
        fi
        ;;
      @url@*)
        url=$(echo "$value" | cut -c6-)
        if command -v curl > /dev/null; then
          decoded=$(mktemp)
          if curl -s -S -f --connect-timeout "${TBC_SECRET_URL_TIMEOUT:-5}" -o "${decoded}" "$url" 2>/dev/null; then
            export ${name}="$(cat ${decoded})"
            log_info "Successfully curl'd secret \e[33;1m${name}\e[0m"
          else
            log_warn "Failed getting secret \e[33;1m${name}\e[0m"
          fi
        elif command -v wget > /dev/null; then
          decoded=$(mktemp)
          if wget -T "${TBC_SECRET_URL_TIMEOUT:-5}" -O "${decoded}" "$url" 2>/dev/null; then
            export ${name}="$(cat ${decoded})"
            log_info "Successfully wget'd secret \e[33;1m${name}\e[0m"
          else
            log_warn "Failed getting secret \e[33;1m${name}\e[0m"
          fi
        else
          log_warn "Couldn't get secret \e[33;1m${name}\e[0m: no http client found"
        fi
        ;;
    esac
  }

  function eval_all_secrets() {
    encoded_vars=$(env | grep -v '^scoped__' | awk -F '=' '/^[a-zA-Z0-9_]*=@(b64|hex|url)@/ {print $1}')
    for var in $encoded_vars; do
      eval_secret "$var"
    done
  }

  # ==== Initialize workspace (TBC standard pattern) ====
  function init_workspace() {
    install_custom_ca_certs
    maybe_install_awk
    unscope_variables
    eval_all_secrets
  }

  # ==== Component-specific functions ====
  function build_app() {
    log_info "Building application: $EXAMPLE_APP_NAME"
    log_info "Using tool: $EXAMPLE_BUILD_TOOL"
    log_info "Build args: $EXAMPLE_BUILD_ARGS"

    case "$EXAMPLE_BUILD_TOOL" in
      maven)  mvn clean package $EXAMPLE_BUILD_ARGS ;;
      gradle) gradle build $EXAMPLE_BUILD_ARGS ;;
      npm)    npm ci && npm run build $EXAMPLE_BUILD_ARGS ;;
      *)      log_info "Using default build (no-op)" ;;
    esac

    log_info "Build completed"
  }

  function test_app() {
    log_info "Testing application: $EXAMPLE_APP_NAME"

    case "$EXAMPLE_BUILD_TOOL" in
      maven)  mvn test ;;
      gradle) gradle test ;;
      npm)    npm test ;;
      *)      log_info "Using default test (no-op)" ;;
    esac

    log_info "Tests passed"
  }

  function lint_app() {
    log_info "Linting application: $EXAMPLE_APP_NAME"
    # Lint logic here
    log_info "Lint passed"
  }

  function publish_app() {
    log_info "Publishing application: $EXAMPLE_APP_NAME"
    log_info "Version: ${example_version:-unknown}"
    # Publish logic here
    log_info "Published successfully"
  }

  # Initialize on script load
  init_workspace
  # ENDSCRIPT

# ==============================================================================
# HIDDEN BASE JOB (users can override for all component jobs)
# ==============================================================================
.example-base:
  image: $EXAMPLE_IMAGE
  # TBC tracking service for analytics
  services:
    - name: "$TBC_TRACKING_IMAGE"
      command: ["--service", "example", "1.0.0"]
  before_script:
    - *example-scripts

# ==============================================================================
# LINT JOB (code quality)
# ==============================================================================
example-lint:
  stage: build
  extends: .example-base
  dependencies: []
  script:
    - lint_app
  rules:
    - if: '$EXAMPLE_LINT_DISABLED == "true"'
      when: never
    - !reference [.test-policy, rules]

# ==============================================================================
# BUILD JOB (compile and create artifacts)
# ==============================================================================
example-build:
  stage: build
  extends: .example-base
  script:
    - build_app
    - |
      # Export variables for downstream jobs (dotenv pattern - TBC standard)
      VERSION="${CI_COMMIT_TAG:-1.0.0-${CI_COMMIT_SHORT_SHA}}"
      {
        echo "example_version=${VERSION}"
        echo "example_artifact=dist/${EXAMPLE_APP_NAME}-${VERSION}.tar.gz"
        echo "example_build_time=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo "example_commit=${CI_COMMIT_SHA}"
      } > example.env
  artifacts:
    paths:
      - dist/
    reports:
      dotenv: example.env
    expire_in: 1 week
  cache:
    - key: "$CI_COMMIT_REF_SLUG-build"
      paths:
        - .cache/
        - node_modules/
        - .m2/
  rules:
    - if: '$EXAMPLE_BUILD_DISABLED == "true"'
      when: never
    - when: on_success

# ==============================================================================
# TEST JOB (unit tests with coverage)
# ==============================================================================
example-test:
  stage: test
  extends: .example-base
  script:
    - test_app
  needs:
    - job: example-build
      artifacts: true
  coverage: '/Coverage:\s*(\d+\.\d+)%/'
  artifacts:
    name: "$CI_JOB_NAME artifacts from $CI_PROJECT_NAME on $CI_COMMIT_REF_SLUG"
    expire_in: 1 day
    access: developer
    when: always
    reports:
      junit: test-results.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
  rules:
    - if: '$EXAMPLE_TEST_DISABLED == "true"'
      when: never
    - !reference [.test-policy, rules]

# ==============================================================================
# PUBLISH JOB (release artifacts)
# ==============================================================================
example-publish:
  stage: publish
  extends: .example-base
  variables:
    GIT_STRATEGY: none
  script:
    - log_info "Publishing version ${example_version}"
    - publish_app
  needs:
    - job: example-build
      artifacts: true
    - job: example-test
      artifacts: false
  rules:
    - if: '$EXAMPLE_PUBLISH_DISABLED == "true"'
      when: never
    - !reference [.delivery-policy, rules]

# ==============================================================================
# DEPLOY JOBS (environment deployment - TBC standard pattern)
# ==============================================================================
example-deploy-review:
  stage: deploy
  extends: .example-base
  script:
    - log_info "Deploying ${example_version} to review environment"
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    url: https://$CI_COMMIT_REF_SLUG.review.example.com
    on_stop: example-deploy-review-cleanup
    auto_stop_in: 1 week
  needs:
    - job: example-build
      artifacts: true
  rules:
    - if: '$CI_MERGE_REQUEST_ID'
      when: on_success
    - when: never

example-deploy-review-cleanup:
  stage: deploy
  extends: .example-base
  variables:
    GIT_STRATEGY: none
  script:
    - log_info "Cleaning up review environment"
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: stop
  needs: []
  rules:
    - if: '$CI_MERGE_REQUEST_ID'
      when: manual
      allow_failure: true
    - when: never

example-deploy-production:
  stage: production
  extends: .example-base
  script:
    - log_info "Deploying ${example_version} to production"
  environment:
    name: production
    url: https://example.com
  needs:
    - job: example-build
      artifacts: true
    - job: example-test
      artifacts: false
    - job: example-publish
      artifacts: false
  rules:
    - !reference [.delivery-policy, rules]
